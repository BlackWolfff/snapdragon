'use strict';

var cyan = require('ansi-cyan');
var yellow = require('ansi-yellow');
var define = require('define-property');

/**
 * Create an instance of `Renderer`. This is only necessary
 * if need to create your own instance.
 *
 * ```js
 * var renderer = new snapdragon.Renderer();
 * ```
 *
 * @param {Object} `ast` Pass the ast generated by `snapdragon.parse()`
 * @param {Object} `options`
 * @api public
 */

function Renderer(ast, opts) {
  if (!(this instanceof Renderer)) {
    return new Renderer(ast, opts);
  }

  this.options = opts || {};
  this.ast = ast;
  this.source = this.ast.source;
  this.stash = ast.stash;
  this.length = ast.nodes.length;
  this.errorsList = [];
  this.parsingErrors = this.ast.errorsList;
  define(this, 'renderers', this.options.renderers || {});
  this.finished = '';

  define(this, 'debug', function() {
    arguments[0] = cyan(arguments[0]);
    return console.log.apply(console, arguments);
  });
}

Renderer.prototype = {
  constructor: Renderer,

  /**
   * Set an error message with the current line number and column.
   *
   * ```js
   * this.error('Error parsing string.');
   * ```
   *
   * @name .error
   * @param {String} `message` Message to use in the Error.
   * @api public
   */

  error: function(message) {
    message = ''
      + ':' + this.column
      + ': ' + message;

    var err = new Error(message);
    err.filename = this.source;
    err.source = this.source;
    err.reason = message;
    console.error(yellow(err));

    if (this.options.silent) {
      this.errorsList.push(err);
    } else {
      throw err;
    }
  },

  /**
   * Register a renderer for a corresponding parser `type`.
   *
   * ```js
   * var ast = snapdragon.parse(str)
   *   .use(function() {
   *     // `type` is the name of the renderer to use
   *     return pos({ type: 'dot' });
   *   })
   *
   * var res = snapdragon.render(ast, options)
   *   .set('dot', function (node) {
   *     return this.emit(node.val);
   *   })
   * ```
   *
   * @name .set
   * @param  {String} `name` Name of the renderer to register
   * @param  {Function} `fn` Function to register
   * @return {Object} `this` for chaining.
   * @chainable
   * @api public
   */

  set: function(name, fn) {
    if (typeof name !== 'string') {
      throw new Error('Renderer#set expects `name` to be a string, but got: ' + name);
    }
    if (typeof fn !== 'function') {
      throw new Error('Renderer#set expects `fn` to be a function, but got: ' + fn);
    }
    this.renderers[name] = fn;
    return this;
  },

  /**
   * @name .emit
   * Emit `str`
   */

  emit: function(str) {
    return str;
  },

  /**
   * Visit `node`
   */

  visit: function(node, prev, next) {
    var fn = this.renderers[node.type];
    if (this.options.verbose) {
      console.log(yellow(node.type));
      console.log(node);
    }
    if (typeof fn !== 'function') {
      var msg = 'visit expects "'
        + node.type + ' | '
        + node.val + '" to be a function.';
      this.error(msg);
    }
    var res = fn.call(this, node, prev, next);
    this.finished += res;
    return res;
  },

  /**
   * Map `visit` over array of `nodes`, optionally using
   * a `delim`
   */

  mapVisit: function(nodes) {
    var buf = '', len = nodes.length;
    for (var i = 0; i < len; i++) {
      buf += this.visit(nodes[i], nodes[i - 1], nodes[i + 1]);
    }
    return buf;
  },

  /**
   * Render a string from the given ast.
   */

  render: function() {
    var opts = this.options;
    var ast = this.ast;
    this.orig = ast.orig;

    // source maps
    if (opts.sourcemap) {
      var sourcemaps = require('../lib/source-maps');
      sourcemaps(this);
    }

    var result = this.mapVisit(ast.nodes);

    if (this.stash.length) {
      var head = this.stash.head;
      var len = head.length;
      var h = '';
      while (len--) h += head[len];
      this.result = h + result;
    } else {
      this.result = result;
    }

    if (opts.sourcemap) {
      this.applySourceMaps();
      this.map = opts.sourcemap === 'generator' ? this.map : this.map.toJSON();
    }
    return this;
  }
};

/**
 * Expose `Renderer`.
 */

module.exports = Renderer;
